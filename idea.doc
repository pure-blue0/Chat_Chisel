在运行model的时候选择进入调试模式->选择要调试的模块->输入数据->执行输出->继续执行/按q退出

解释：
1.因为RTL中的CPU的寄存器都是先写后读的，因此如果此时decode中有一条指令在从A0取值，在WB中有一条指令要向A0写入数据，此时
decode从A0中读取出的数据是WB阶段写入的最新数据；但是在model中，由于指令是顺序进行的，因此同样的情况，decode中读出的数据
是A0的旧数据，而非最新写入的数据，因此需要在WB阶段，也加入一个数据前递。

2.对exe stage中forward data 部分的解释
->首先这部分代码对应的是scala/hazard中


1.bht btb的更新往后放到mem中
2.


问题：
1.后端重定向地址target_pc的产生是否少考虑了一种情况
->你的代码中只考虑了指令为jalr时，target_pc=ALU_Result；其余情况都是：target_pc=ex_pc+imm；
->如果分支预测为不跳转，然后到exe stage执行完成后发现分支预测为跳转，那么此时采用后端重定向的target_pc是可以成功回到正确的地址的
->但如果分支预测为跳转，但是到exe stage执行完成后发现分支预测为不跳转，那么此时需要获取后端重定向的地址target_pc=ex_pc+4，但是看你的代码里好像没有考虑这个情况。

